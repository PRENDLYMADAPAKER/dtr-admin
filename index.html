<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Admin Panel — QR Time-In</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #0f172a;
      color: white;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #1e293b;
      padding: 10px;
      text-align: center;
      font-size: 1.4em;
      font-weight: bold;
    }
    #scanner {
      text-align: center;
      padding: 10px;
    }
    #logs-controls {
      padding: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    #logs {
      padding: 10px;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background-color: #1e293b;
    }
    th, td {
      border: 1px solid #334155;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #0f172a;
      cursor: pointer;
    }
    button {
      background-color: #06b6d4;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #0891b2;
    }
    input {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #475569;
    }
  </style>
</head>
<body>
  <header>Admin Panel — QR Time-In</header>
  <div id="scanner">
    <div id="qr-reader" style="width:300px;margin:auto;"></div>
  </div>

  <div id="logs-controls">
    <input type="text" id="searchInput" placeholder="Search logs...">
    <button onclick="exportCSV()">Export CSV</button>
    <button onclick="printLogs()">Print Logs</button>
    <button onclick="resetLogs()">Reset Logs</button>
  </div>

  <div id="logs">
    <table id="logsTable">
      <thead>
        <tr>
          <th onclick="sortTable(0)">Name</th>
          <th onclick="sortTable(1)">Email</th>
          <th onclick="sortTable(2)">Time</th>
        </tr>
      </thead>
      <tbody id="logsBody"></tbody>
    </table>
  </div>
  <!-- ZXing library (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.19.1/umd/index.min.js"></script>

  <!-- Main module script -->
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getDatabase,
    ref,
    onValue,
    get,
    set,
    remove,
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

  // --------- Firebase config (your project) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyBYYZrsZECXM2UpW4-38sGQLaPqAqkjSWI",
    authDomain: "dtr-project-66048.firebaseapp.com",
    databaseURL: "https://dtr-project-66048-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "dtr-project-66048",
    storageBucket: "dtr-project-66048.appspot.com",
    messagingSenderId: "271445506225",
    appId: "1:271445506225:web:fcb04d0454e1302de14a90",
    measurementId: "G-R22CLKSPCP"
  };
  // ---------------------------------------------------

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // DOM refs
  const qrContainer = document.getElementById('qr-reader');
  const logsBody = document.getElementById('logsBody');
  const searchInput = document.getElementById('searchInput');

  // create a video element for scanner (insert into qrContainer)
  const videoEl = document.createElement('video');
  videoEl.setAttribute('playsinline', 'true');
  videoEl.style.width = '320px';
  videoEl.style.maxWidth = '100%';
  videoEl.style.borderRadius = '8px';
  videoEl.style.boxShadow = '0 0 12px rgba(34,197,94,0.3)';
  qrContainer.innerHTML = ''; // clear placeholder
  qrContainer.appendChild(videoEl);

  // ZXing code reader
  const codeReader = new ZXing.BrowserQRCodeReader();
  let scanning = false;
  let scanCooldowns = {};

  // In-memory logs for current day
  let logsData = []; // each item: { uid, name, email, clinicalLevel, date, time, ts }

  // Helpers: date/time functions
  function todayYMD(d = new Date()){
    const pad = n => n < 10 ? '0' + n : n;
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }
  function timeHMS(d = new Date()){
    const pad = n => n < 10 ? '0' + n : n;
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  // sanitize
  function escapeHtml(s){
    if (s == null) return '';
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // Render logs table
  function renderLogs(filter = ''){
    const ft = filter.trim().toLowerCase();
    const rows = logsData
      .filter(r => {
        if(!ft) return true;
        return (r.name || '').toLowerCase().includes(ft)
          || (r.email || '').toLowerCase().includes(ft)
          || (r.clinicalLevel || '').toLowerCase().includes(ft)
          || (r.time || '').toLowerCase().includes(ft);
      })
      .map(r => `<tr>
        <td>${escapeHtml(r.name||'')}</td>
        <td>${escapeHtml(r.email||'')}</td>
        <td>${escapeHtml(r.clinicalLevel||'')}</td>
        <td>${escapeHtml(r.date||'')}</td>
        <td>${escapeHtml(r.time||'')}</td>
      </tr>`).join('');
    logsBody.innerHTML = rows || `<tr><td colspan="5" style="text-align:center;color:#94a3b8">No records</td></tr>`;
  }

  // Listen to today's logs in /timeIns/{date}
  function listenTodayLogs(){
    const dateStr = todayYMD();
    const logsRef = ref(db, `timeIns/${dateStr}`);
    onValue(logsRef, snap => {
      const val = snap.val() || {};
      // normalize to array
      logsData = Object.values(val).map(v => ({
        uid: v.uid || '',
        name: v.name || '',
        email: v.email || '',
        clinicalLevel: v.clinicalLevel || (v.clinicalLevel === 0 ? '0' : ''),
        date: v.date || dateStr,
        time: v.time || '',
        ts: v.ts || 0
      })).sort((a,b) => (b.ts||0) - (a.ts||0));
      renderLogs(searchInput.value || '');
    });
  }

  // Export CSV (exposed to global for Part1 buttons)
  function exportCSV(){
    if (!logsData || logsData.length === 0){
      alert('No data to export');
      return;
    }
    const headers = ['Name','Email','Clinical Level','Date','Time In'];
    const rows = logsData.map(r => [r.name, r.email, r.clinicalLevel || '', r.date, r.time]);
    let csv = headers.join(',') + '\r\n';
    rows.forEach(cols => {
      csv += cols.map(c => `"${String(c||'').replace(/"/g,'""')}"`).join(',') + '\r\n';
    });
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dtr_logs_${todayYMD()}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  window.exportCSV = exportCSV;

  // Print logs
  function printLogs(){
    const html = `<html><head><title>DTR Logs ${todayYMD()}</title>
      <style>body{font-family:Arial;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ccc;padding:6px;text-align:left;}th{background:#eee}</style>
      </head><body>
      <h2>DTR Logs - ${todayYMD()}</h2>
      <table><thead><tr><th>Name</th><th>Email</th><th>Clinical Level</th><th>Date</th><th>Time</th></tr></thead><tbody>
      ${logsData.map(r => `<tr><td>${escapeHtml(r.name)}</td><td>${escapeHtml(r.email)}</td><td>${escapeHtml(r.clinicalLevel)}</td><td>${escapeHtml(r.date)}</td><td>${escapeHtml(r.time)}</td></tr>`).join('')}
      </tbody></table></body></html>`;
    const w = window.open('', '_blank', 'width=900,height=700');
    w.document.write(html);
    w.document.close();
    w.focus();
    w.print();
  }
  window.printLogs = printLogs;

  // Reset logs (archive to /archives/{date} then remove /timeIns/{date})
  async function resetLogs(){
    if (!confirm('Archive today and clear live results? This will move current day logs to /archives/{date} and clear live results.')) return;
    const dateStr = todayYMD();
    const liveRef = ref(db, `timeIns/${dateStr}`);
    const archiveRef = ref(db, `archives/${dateStr}`);
    try {
      // get live
      const snapshot = await get(liveRef);
      if (!snapshot.exists()){
        alert('No live logs to archive for today.');
        return;
      }
      const data = snapshot.val();
      // write to archives (overwrite safe)
      await set(archiveRef, data);
      // remove live
      await remove(liveRef);
      // also optionally remove per-user DTR entries (under users/{uid}/dtr/{date})? We'll keep them
      // refresh local data
      logsData = [];
      renderLogs('');
      alert('Archived and cleared today\'s logs.');
    } catch(err){
      console.error('resetLogs error', err);
      alert('Failed to reset logs: ' + (err.message || err));
    }
  }
  window.resetLogs = resetLogs;

  // Sort table helper (called by inline onclicks in Part1)
  let currentSort = { col: -1, asc: true };
  function sortTable(colIndex){
    // columns: 0=name,1=email,2=time (Part1 used 3 columns)
    const keyMap = {0:'name',1:'email',2:'time'};
    const key = keyMap[colIndex];
    if (!key) return;
    if (currentSort.col === colIndex) currentSort.asc = !currentSort.asc;
    else { currentSort.col = colIndex; currentSort.asc = true; }
    logsData.sort((a,b) => {
      const va = (a[key] || '').toString().toLowerCase();
      const vb = (b[key] || '').toString().toLowerCase();
      if (va < vb) return currentSort.asc ? -1 : 1;
      if (va > vb) return currentSort.asc ? 1 : -1;
      return 0;
    });
    renderLogs(searchInput.value || '');
  }
  window.sortTable = sortTable;

  // Start scanner (using ZXing) and store records in DB when scanned
  async function startScanner(){
    if (scanning) return;
    try {
      const devices = await codeReader.listVideoInputDevices();
      if (!devices || devices.length === 0){
        alert('No camera found.');
        return;
      }
      const preferred = devices.find(d => /back|rear|environment/i.test(d.label)) || devices[0];
      scanning = true;
      // start decoding from device
      codeReader.decodeFromVideoDevice(preferred.deviceId, videoEl, async (result, err) => {
        if (result && result.getText){
          const text = result.getText();
          await handleScanResult(text);
        }
        if (err && !(err instanceof ZXing.NotFoundException)) {
          console.error(err);
        }
      });
    } catch(e){
      console.error('startScanner error', e);
      alert('Scanner error: ' + e.message);
    }
  }

  // Stop scanner
  function stopScanner(){
    try {
      codeReader.reset();
      scanning = false;
    } catch(e){}
  }

  // Handle a scanned QR (UID expected)
  async function handleScanResult(text){
    const uid = String(text || '').trim();
    if (!uid) return;
    // simple debounce per uid
    const now = Date.now();
    if (scanCooldowns[uid] && (now - scanCooldowns[uid] < 4000)) return;
    scanCooldowns[uid] = now;

    const dateStr = todayYMD();
    const timeStr = timeHMS();
    try {
      // fetch profile: users/{uid}/profile
      const profSnap = await get(ref(db, `users/${uid}/profile`));
      if (!profSnap.exists()){
        alert('UID not registered: ' + uid);
        return;
      }
      const profile = profSnap.val();
      const clinicalLevel = profile.clinicalLevel || '';

      // check if already timed in today (users/{uid}/dtr/{date})
      const dtrSnap = await get(ref(db, `users/${uid}/dtr/${dateStr}`));
      if (dtrSnap.exists()){
        alert(`${profile.name} already timed in at ${dtrSnap.val().timeIn}`);
        return;
      }

      // write DTR per-user and write timeIns/{date}/{uid}
      await set(ref(db, `users/${uid}/dtr/${dateStr}`), { timeIn: timeStr, date: dateStr, ts: Date.now() });
      await set(ref(db, `timeIns/${dateStr}/${uid}`), {
        uid,
        name: profile.name || '',
        email: profile.email || '',
        clinicalLevel: clinicalLevel || '',
        date: dateStr,
        time: timeStr,
        ts: Date.now()
      });

      // success feedback
      // update local logsData is handled by onValue listener
    } catch(err){
      console.error('handleScanResult', err);
      alert('Failed to record time-in: ' + (err.message || err));
    }
  }

  // wire start/stop buttons: create small control UI if not present
  // Part1 did not include start/stop buttons; if you want, you can add them. For demo we auto-start scanner.
  try { startScanner(); } catch(e){ console.warn('auto start failed', e); }

  // Search filtering
  searchInput.addEventListener('input', () => {
    renderLogs(searchInput.value || '');
  });

  // Auto midnight archive: schedule next midnight then archive+clear
  function scheduleMidnightArchive(){
    const now = new Date();
    const next = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1, 0,0,5); // 00:00:05 next day
    const ms = next.getTime() - now.getTime();
    setTimeout(async () => {
      try {
        const dateStr = todayYMD(new Date(Date.now() - 24*3600*1000)); // archive the previous day
        const liveRef = ref(db, `timeIns/${dateStr}`);
        const archiveRef = ref(db, `archives/${dateStr}`);
        const snap = await get(liveRef);
        if (snap.exists()){
          await set(archiveRef, snap.val());
          await remove(liveRef);
          console.info('Auto-archived logs for', dateStr);
        } else {
          console.info('No logs to archive for', dateStr);
        }
      } catch(e){
        console.error('Auto-archive failed', e);
      } finally {
        scheduleMidnightArchive(); // reschedule for next day
      }
    }, ms);
  }
  // start the schedule
  scheduleMidnightArchive();

  // Start listening to current day's logs
  listenTodayLogs();

  // Expose some functions globally because Part1 buttons call them inline
  window.exportCSV = exportCSV;
  window.printLogs = printLogs;
  window.resetLogs = resetLogs;
  window.sortTable = sortTable;
  // also expose start/stop if needed
  window.startScanner = startScanner;
  window.stopScanner = stopScanner;

  </script>
</body>
</html>
